<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>3D Voxel Chess - Defensive Support Lines</title>
    <style>
        html, body {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        @media (max-width: 600px) {
            #setup-overlay h1 { font-size: 1.35em; }
            #setup-overlay h2 { font-size: 1em; }
            .setup-section { max-width: 98vw; }
            .setup-button, #start-game-button { font-size: 1.1em; padding: 12px 10px; }
            #start-game-button { padding: 14px 10vw; font-size: 1.2em; }
            #info { font-size: 0.95em; min-width: 110px; padding: 7px 8px; }
        }
        @media (max-width: 400px) {
            #setup-overlay h1 { font-size: 1em; }
            #setup-overlay h2 { font-size: 0.9em; }
            .setup-button, #start-game-button { font-size: 0.95em; padding: 10px 6px; }
        }
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #222; color: #fff; }
        #setup-overlay { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; text-align: center; padding: 20px; }
        #setup-overlay h1 { margin-bottom: 15px; color: #fff; font-weight: 300; letter-spacing: 1px; font-size: 2.5em; }
        #setup-overlay h2 { margin-bottom: 10px; margin-top: 15px; color: #ccc; font-weight: 400; font-size: 1.1em;}
        .setup-section { margin-bottom: 10px; width: 90%; max-width: 550px; }
        .setup-button { background-color: #4a4a5a; color: #eee; border: 1px solid #666; padding: 9px 18px; margin: 5px; font-size: 0.95em; cursor: pointer; border-radius: 4px; transition: background-color 0.2s, border-color 0.2s; }
        .setup-button:hover { background-color: #5a5a6a; border-color: #888; }
        .setup-button.selected { background-color: #5a8cc0; border-color: #7ab8f0; }
        #start-game-button { background-color: #4caf50; border: none; color: white; margin-top: 25px; padding: 15px 40px; font-size: 1.1em; font-weight: bold; letter-spacing: 0.5px; }
        #start-game-button:hover { background-color: #5cb860; }
        #opponent-select label, #capture-highlight-select label { margin: 0 10px 0 3px; font-size: 0.95em; color: #ccc;}
        #opponent-select input, #capture-highlight-select input { vertical-align: middle; margin-right: 4px; }
        #container { width: 100vw; height: 100vh; display: none; touch-action: none; }
        #info { position: absolute; top: 15px; left: 15px; background: rgba(15, 20, 30, 0.85); padding: 12px 18px; border-radius: 8px; font-size: 1em; line-height: 1.6; display: none; z-index: 5; border: 1px solid rgba(100, 120, 150, 0.5); min-width: 160px; }
        #info div { margin-bottom: 6px; }
        #info span { font-weight: bold; }
        #info #status.check, #info #status.checkmate { color: #ff8888; font-weight: bold; }
        canvas { display: block; cursor: pointer; }
        input, button { touch-action: manipulation; }
    </style>
</head>
<body>
    <!-- Setup Overlay -->
    <div id="setup-overlay">
        <h1>3D Voxel Chess</h1>
        <div class="setup-section"> <h2>Starting "Height" (Along UP Axis):</h2> <div id="height-setup"> <button class="setup-button height-button selected" data-setup="low">Floor (0)</button> <button class="setup-button height-button" data-setup="classic">Classic (W:0, B:Max)</button> <button class="setup-button height-button" data-setup="middle">Middle</button> <button class="setup-button height-button" data-setup="high">Ceiling (Max)</button> <button class="setup-button height-button" data-setup="random">Random</button> </div> </div>
        <div class="setup-section"> <h2>"UP" Axis:</h2> <div id="axis-setup"> <button class="setup-button axis-button" data-axis="x">X</button> <button class="setup-button axis-button selected" data-axis="y">Y (Default)</button> <button class="setup-button axis-button" data-axis="z">Z</button> </div> </div>
         <div class="setup-section"> <h2>Board Height (UP Axis Max):</h2> <input type="number" id="max-height-input" min="2" max="8" value="8" style="width: 50px; padding: 5px; font-size: 1em;"> (2-8) </div>
        <div class="setup-section"> <h2>Opponent:</h2> <div id="opponent-select"> <input type="radio" id="opp-human" name="opponent" value="human" checked> <label for="opp-human">Human</label> <input type="radio" id="opp-ai-random" name="opponent" value="random"> <label for="opp-ai-random">AI (Random)</label> <input type="radio" id="opp-ai-greedy" name="opponent" value="greedy"> <label for="opp-ai-greedy">AI (Greedy)</label> </div> </div>
        <div class="setup-section"> <h2>Options:</h2>
            <div id="capture-highlight-select"> <input type="checkbox" id="highlight-captures" name="highlight-captures" checked> <label for="highlight-captures">Highlight Captures (Red)</label> </div>
            <div style="margin-top:5px;"><label for="attack-mode" style="margin-right:5px;">Attack Lines (Selected):</label><select id="attack-mode" name="attack-mode" style="margin-left:2px;"><option value="none">Off</option><option value="captures" selected>Captures</option><option value="rays">Full Rays</option></select> </div>
            <div style="margin-top:5px;"><input type="checkbox" id="show-support-lines" name="show-support-lines" checked> <label for="show-support-lines">Show Support Lines</label></div>
            <div style="margin-top:5px;"><input type="checkbox" id="show-conflict-rays" name="show-conflict-rays" checked> <label for="show-conflict-rays">Show Conflict Rays</label></div>
        </div>
        <button id="start-game-button">Start Game</button>
    </div>

    <div id="container"></div>
    <div id="info"> <div><span id="turn-label">Turn:</span> <span id="turn">White</span></div> <div>White Material: <span id="white-score">0</span></div> <div>Black Material: <span id="black-score">0</span></div> <div>Status: <span id="status">Waiting...</span></div> </div>

    <script> document.addEventListener('touchmove',e=>{if(e.touches.length>1)e.preventDefault();},{passive:false});let lT=0;document.addEventListener('touchend',e=>{let n=(new Date()).getTime();if(n-lT<=300)e.preventDefault();lT=n;},false); </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script> // Main Game Script
        const BOARD_SIZE = 8; const VOXEL_SIZE = 1.0; const HALF_BOARD_XZ = BOARD_SIZE / 2.0;
        const PIECE_TYPES = { PAWN: 'pawn', ROOK: 'rook', KNIGHT: 'knight', BISHOP: 'bishop', QUEEN: 'queen', KING: 'king' };
        const COLORS = { WHITE: 'white', BLACK: 'black' };
        const MATERIALS = { /* ... Materials ... */
            [COLORS.WHITE]: new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.7, metalness: 0.1 }),
            [COLORS.BLACK]: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.1 }),
            ROYAL_WHITE: new THREE.MeshStandardMaterial({ color: 0xfff8e1, roughness: 0.5, metalness: 0.2 }),
            ROYAL_BLACK: new THREE.MeshStandardMaterial({ color: 0x404050, roughness: 0.5, metalness: 0.2 }),
            ROYAL_BASE_WHITE: new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.4, metalness: 0.3 }),
            ROYAL_BASE_BLACK: new THREE.MeshStandardMaterial({ color: 0x504040, roughness: 0.4, metalness: 0.3 }),
            SELECTED: new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x44ff44, emissiveIntensity: 0.8 }),
            VALID_MOVE: new THREE.MeshStandardMaterial({ color: 0xffd700, transparent: true, opacity: 0.4 }),
            CAPTURE_MOVE: new THREE.MeshStandardMaterial({ color: 0xff6666, transparent: true, opacity: 0.55 }),
            KING_CHECK: new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff4444, emissiveIntensity: 1.0 }),
            FLOOR: new THREE.MeshStandardMaterial({ color: 0x6688aa, transparent: true, opacity: 0.3, side: THREE.DoubleSide }),
            AXIS_LABEL: new THREE.MeshBasicMaterial({ color: 0xeeeeee }),
            GRID_LOW: new THREE.LineBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 }),
            GRID_MID: new THREE.LineBasicMaterial({ color: 0x88aa88, transparent: true, opacity: 0.35 }),
            GRID_HIGH: new THREE.LineBasicMaterial({ color: 0xaa8888, transparent: true, opacity: 0.35 }),
            LABEL_WHITE: new THREE.MeshBasicMaterial({ color: 0x111111 }),
            LABEL_BLACK: new THREE.MeshBasicMaterial({ color: 0xeeeeee }),
            SUPPORT_LINE_WHITE: new THREE.MeshBasicMaterial({color:0x88ff88, transparent:true, opacity:0.45}),
            SUPPORT_LINE_BLACK: new THREE.MeshBasicMaterial({color:0x33aa33, transparent:true, opacity:0.45}),
            GHOST_LINE_CAPTURE_WHITE: new THREE.MeshBasicMaterial({ color: 0xffaa55, transparent: true, opacity: 0.65 }),
            GHOST_LINE_CAPTURE_BLACK: new THREE.MeshBasicMaterial({ color: 0xdd8844, transparent: true, opacity: 0.65 }),
            GHOST_LINE_NON_CAPTURE_WHITE: new THREE.MeshBasicMaterial({ color: 0xaaaaff, transparent: true, opacity: 0.4 }),
            GHOST_LINE_NON_CAPTURE_BLACK: new THREE.MeshBasicMaterial({ color: 0x7777dd, transparent: true, opacity: 0.4 }),
            PIECE_STATE_UNDER_ATTACK: new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0xcc2222, emissiveIntensity: 0.6, roughness: 0.6, metalness: 0.1 }),
            PIECE_STATE_THREATENING: new THREE.MeshStandardMaterial({ color: 0x8888ff, emissive: 0x6666ee, emissiveIntensity: 0.5, roughness: 0.6, metalness: 0.1 }),
            CONFLICT_RAY_WHITE_ATTACKING: new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.7 }),
            CONFLICT_RAY_BLACK_ATTACKING: new THREE.MeshBasicMaterial({ color: 0xcc6600, transparent: true, opacity: 0.7 }),
        };
        const PIECE_VALUES = { [PIECE_TYPES.PAWN]: 1, [PIECE_TYPES.KNIGHT]: 3, [PIECE_TYPES.BISHOP]: 3, [PIECE_TYPES.ROOK]: 5, [PIECE_TYPES.QUEEN]: 9, [PIECE_TYPES.KING]: 0 };
        const CAPTURED_SCALE = 0.5; const CAPTURED_SPACING = VOXEL_SIZE * (CAPTURED_SCALE + 0.2); const AI_DELAY = 500;

        let scene, camera, renderer, controls = null;
        let boardState = []; let pieceMeshes = []; let validMoveMeshes = [];
        let ghostLines = []; let ghostHash = new Set();
        let supportLines = []; let supportHash = new Set();
        let conflictRayMeshes = []; let conflictRayHash = new Set();
        let helvetikerFont = null;
        let gameState = { currentPlayer: COLORS.WHITE, gameStatus: 'waiting', lastMove: null, kingPositions: { [COLORS.WHITE]: null, [COLORS.BLACK]: null }, selectedSetupType: 'low', upAxis: 'y', opponentType: 'human', aiColor: null, isAiTurn: false, highlightCaptures: true, attackMode: 'captures', supportLines: true, showConflictRays: true, maxHeight: 8 };
        let capturedByWhite = []; let capturedByBlack = [];
        let whiteScore = 0; let blackScore = 0;
        let capturedWhiteDisplayMeshes = []; let capturedBlackDisplayMeshes = [];
        let selectedPiece = null;
        let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2();
        let floorPlaneMesh = null; let axisLabelMeshes = []; let gridHelperMeshes = [];
        let audioContext = null;

        function init() { console.log(`Init: Setup ${gameState.selectedSetupType}, UP ${gameState.upAxis}, Height ${gameState.maxHeight}, Opponent ${gameState.opponentType}, Highlight Captures: ${gameState.highlightCaptures}, Support Lines: ${gameState.supportLines}, Conflict Rays: ${gameState.showConflictRays}`); gameState.gameStatus = 'playing'; setupScene(); setupBoardState(); setupBoardVisualization(); setupInteraction(); setupAudio(); loadFontAndStart(); }
        function startGame() { const selOpp = document.querySelector('input[name="opponent"]:checked'); gameState.opponentType = selOpp ? selOpp.value : 'human'; gameState.aiColor = (gameState.opponentType !== 'human') ? COLORS.BLACK : null; gameState.highlightCaptures = document.getElementById('highlight-captures').checked; gameState.supportLines = document.getElementById('show-support-lines').checked; gameState.showConflictRays = document.getElementById('show-conflict-rays').checked; const mhInput = document.getElementById('max-height-input'); let hVal = parseInt(mhInput.value, 10); if (isNaN(hVal) || hVal < 2 || hVal > 8) { hVal = 8; mhInput.value = 8; } gameState.maxHeight = hVal; document.getElementById('setup-overlay').style.display = 'none'; document.getElementById('container').style.display = 'block'; document.getElementById('info').style.display = 'block'; init(); }
        function loadFontAndStart() {
            const loader = new THREE.FontLoader();
            loader.load('https://unpkg.com/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
                font => { 
                    helvetikerFont = font; setupInitialPieces(); setupPieceMeshes(); setupAxisLabels();
                    try { if (typeof THREE.OrbitControls === 'undefined') { throw new Error("OrbitControls script not loaded."); } controls = new THREE.OrbitControls(camera, renderer.domElement); if (controls) { const halfH = gameState.maxHeight / 2.0; switch (gameState.upAxis) { case 'x': controls.up.set(1,0,0); break; case 'z': controls.up.set(0,0,1); break; default: controls.up.set(0,1,0); } controls.enableDamping=true; controls.dampingFactor=0.1; controls.screenSpacePanning=false; controls.minDistance=BOARD_SIZE*0.5; controls.maxDistance=(BOARD_SIZE+gameState.maxHeight)*2; const tP={x:0,y:0,z:0}; tP[gameState.upAxis]=(halfH-0.5)*VOXEL_SIZE; controls.target.set(tP.x,tP.y,tP.z); controls.update(); console.log("OrbitControls configured successfully."); } else { throw new Error("OrbitControls object creation failed."); } } catch(e) { console.error("OrbitControls init error:", e); controls = null; }
                    updateInfoPanel(); drawGhostLines(); drawSupportLines(); updateAllPieceTacticalVisuals(); drawConflictRays(); maybeTriggerAiMove(); animate();
                },
                undefined, 
                err => { console.error('Font load failed:',err); setupInitialPieces();setupPieceMeshes(); try { if (typeof THREE.OrbitControls === 'undefined') { throw new Error("OrbitControls script not loaded."); } controls = new THREE.OrbitControls(camera, renderer.domElement); if (controls) { const halfH = gameState.maxHeight / 2.0; switch (gameState.upAxis) { case 'x': controls.up.set(1,0,0); break; case 'z': controls.up.set(0,0,1); break; default: controls.up.set(0,1,0); } controls.enableDamping=true; controls.dampingFactor=0.1; controls.screenSpacePanning=false; controls.minDistance=BOARD_SIZE*0.5; controls.maxDistance=(BOARD_SIZE+gameState.maxHeight)*2; const tP={x:0,y:0,z:0}; tP[gameState.upAxis]=(halfH-0.5)*VOXEL_SIZE; controls.target.set(tP.x,tP.y,tP.z); controls.update(); } } catch(e) { console.error("OrbitControls init error (font failed):", e); controls = null; } updateInfoPanel(); drawGhostLines(); drawSupportLines(); updateAllPieceTacticalVisuals(); drawConflictRays(); maybeTriggerAiMove(); animate(); }
            );
            const attSel = document.getElementById('attack-mode'); if(attSel){attSel.value=gameState.attackMode; attSel.addEventListener('change',e=>{gameState.attackMode=e.target.value;drawGhostLines();});}
            const supLinesCb = document.getElementById('show-support-lines'); if(supLinesCb){supLinesCb.checked=gameState.supportLines; supLinesCb.addEventListener('change',e=>{gameState.supportLines=e.target.checked;drawSupportLines();});}
            const confRaysCb = document.getElementById('show-conflict-rays'); if (confRaysCb) { confRaysCb.checked = gameState.showConflictRays; confRaysCb.addEventListener('change', e => { gameState.showConflictRays = e.target.checked; drawConflictRays(); }); }
        }

        function setupAudio() { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized.");} catch(e) { console.warn("Web Audio API not supported.", e); audioContext = null; } }
        function playSound(type) { if (!audioContext) return; let freq1 = 440, freq2 = 440, duration = 0.05, type1 = 'sine', type2 = 'sine', vol = 0.3; switch(type) { case 'select': freq1 = 880; duration = 0.03; vol = 0.1; type1 = 'square'; break; case 'move': freq1 = 523; duration = 0.08; vol = 0.2; type1 = 'triangle'; break; case 'capture': freq1 = 261; freq2 = 294; duration = 0.15; vol = 0.3; type1 = 'sawtooth'; type2 = 'square'; break; case 'check': freq1 = 1046; freq2=1174; duration = 0.1; vol=0.25; type1 = 'square'; type2='sine'; break; case 'checkmate': freq1 = 130; freq2 = 164; duration = 0.8; vol = 0.4; type1 = 'sawtooth'; type2 = 'square'; break; } const osc1 = audioContext.createOscillator(); const gainNode = audioContext.createGain(); osc1.type = type1; osc1.frequency.setValueAtTime(freq1, audioContext.currentTime); gainNode.gain.setValueAtTime(vol, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration); osc1.connect(gainNode); gainNode.connect(audioContext.destination); osc1.start(audioContext.currentTime); osc1.stop(audioContext.currentTime + duration); if (type === 'capture' || type === 'check' || type === 'checkmate') { const osc2 = audioContext.createOscillator(); const gainNode2 = audioContext.createGain(); osc2.type = type2; osc2.frequency.setValueAtTime(freq2, audioContext.currentTime + duration * 0.1); gainNode2.gain.setValueAtTime(vol * 0.8, audioContext.currentTime + duration * 0.1); gainNode2.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration); osc2.connect(gainNode2); gainNode2.connect(audioContext.destination); osc2.start(audioContext.currentTime + duration * 0.1); osc2.stop(audioContext.currentTime + duration); } }
        function setupScene() { scene = new THREE.Scene(); scene.background = new THREE.Color(0x506075); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); const halfHeight = gameState.maxHeight / 2.0; switch (gameState.upAxis) { case 'x': camera.position.set(gameState.maxHeight * 1.3, BOARD_SIZE * 0.8, BOARD_SIZE * 0.8); break; case 'z': camera.position.set(BOARD_SIZE * 0.8, BOARD_SIZE * 0.8, gameState.maxHeight * 1.2); break; case 'y': default: camera.position.set(BOARD_SIZE * 0.6, gameState.maxHeight * 1.2, BOARD_SIZE * 1.0); break; } renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); document.getElementById('container').appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0xeeeeff, 0.8); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); directionalLight.position.set(10 * VOXEL_SIZE, gameState.maxHeight * 1.5 * VOXEL_SIZE, 8 * VOXEL_SIZE); scene.add(directionalLight); }
        function setupBoardVisualization() { if (floorPlaneMesh) scene.remove(floorPlaneMesh); gridHelperMeshes.forEach(grid => scene.remove(grid)); gridHelperMeshes = []; const oldOutline = scene.children.find(child => child.type === "LineSegments" && child.geometry.type === "EdgesGeometry"); if(oldOutline) scene.remove(oldOutline); const floorSize = BOARD_SIZE * VOXEL_SIZE; const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize); floorPlaneMesh = new THREE.Mesh(floorGeometry, MATERIALS.FLOOR); const floorLevelCoord = 0; const floorOffset = -0.01; const gridOffset = 0.01; const up = gameState.upAxis; const maxHeight = gameState.maxHeight; const halfHeight = maxHeight / 2.0; const midLevel = Math.floor((maxHeight -1) / 2); const topLevel = maxHeight - 1; let floorRotation = new THREE.Euler(); let gridRotation = new THREE.Euler(); const floorPos = {x: 0, y: 0, z: 0}; const midPos = {x: 0, y: 0, z: 0}; const topPos = {x: 0, y: 0, z: 0}; floorPos[up] = (floorLevelCoord - halfHeight + 0.5 + floorOffset) * VOXEL_SIZE; midPos[up] = (midLevel - halfHeight + 0.5 + gridOffset) * VOXEL_SIZE; topPos[up] = (topLevel - halfHeight + 0.5 + gridOffset) * VOXEL_SIZE; if (up === 'x') { floorRotation.set(0, Math.PI / 2, 0); gridRotation.set(0, 0, Math.PI / 2); } else if (up === 'z') { gridRotation.set(Math.PI / 2, 0, 0); } else { floorRotation.set(-Math.PI / 2, 0, 0); } floorPlaneMesh.rotation.copy(floorRotation); floorPlaneMesh.position.set(floorPos.x, floorPos.y, floorPos.z); scene.add(floorPlaneMesh); const gridLow = new THREE.GridHelper(BOARD_SIZE, BOARD_SIZE, MATERIALS.GRID_LOW.color, MATERIALS.GRID_LOW.color); gridLow.material = MATERIALS.GRID_LOW; gridLow.rotation.copy(gridRotation); const lowPos = {x:0, y:0, z:0}; lowPos[up] = (floorLevelCoord - halfHeight + 0.5 + gridOffset) * VOXEL_SIZE; gridLow.position.set(lowPos.x, lowPos.y, lowPos.z); scene.add(gridLow); gridHelperMeshes.push(gridLow); if (maxHeight > 3 && midLevel > 0 && midLevel !== topLevel) { const gridMid = new THREE.GridHelper(BOARD_SIZE, BOARD_SIZE, MATERIALS.GRID_MID.color, MATERIALS.GRID_MID.color); gridMid.material = MATERIALS.GRID_MID; gridMid.rotation.copy(gridRotation); gridMid.position.set(midPos.x, midPos.y, midPos.z); scene.add(gridMid); gridHelperMeshes.push(gridMid); } if (maxHeight > 1 && topLevel > 0 && topLevel !== midLevel) { const gridHigh = new THREE.GridHelper(BOARD_SIZE, BOARD_SIZE, MATERIALS.GRID_HIGH.color, MATERIALS.GRID_HIGH.color); gridHigh.material = MATERIALS.GRID_HIGH; gridHigh.rotation.copy(gridRotation); gridHigh.position.set(topPos.x, topPos.y, topPos.z); scene.add(gridHigh); gridHelperMeshes.push(gridHigh); } }
        function setupBoardState() { boardState = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null).map(() => Array(gameState.maxHeight).fill(null) )); capturedByWhite = []; capturedByBlack = []; whiteScore = 0; blackScore = 0; capturedWhiteDisplayMeshes.forEach(m => scene.remove(m)); capturedBlackDisplayMeshes.forEach(m => scene.remove(m)); capturedWhiteDisplayMeshes = []; capturedBlackDisplayMeshes = []; axisLabelMeshes.forEach(m => scene.remove(m)); axisLabelMeshes = []; gridHelperMeshes.forEach(m=>scene.remove(m)); gridHelperMeshes=[]; gameState.lastMove = null; gameState.kingPositions = { [COLORS.WHITE]: null, [COLORS.BLACK]: null }; gameState.currentPlayer = COLORS.WHITE; gameState.isAiTurn = false; selectedPiece = null; clearHighlights(); }
        function setupInitialPieces() { let whiteHeight, blackHeight; let isRandomHeight = false; const maxHeight = gameState.maxHeight; const midLevel = Math.max(0, Math.floor((maxHeight - 1) / 2)); const highLevelBack = maxHeight - 1; const classicBlackHeight = Math.max(0, maxHeight - 1); switch (gameState.selectedSetupType) { case 'middle': whiteHeight = midLevel; blackHeight = midLevel; break; case 'high': whiteHeight = highLevelBack; blackHeight = highLevelBack; break; case 'random': isRandomHeight = true; break; case 'classic': whiteHeight = 0; blackHeight = classicBlackHeight; break; case 'low': default: whiteHeight = 0; blackHeight = 0; break; } const backRankOrder = [ PIECE_TYPES.ROOK, PIECE_TYPES.KNIGHT, PIECE_TYPES.BISHOP, PIECE_TYPES.QUEEN, PIECE_TYPES.KING, PIECE_TYPES.BISHOP, PIECE_TYPES.KNIGHT, PIECE_TYPES.ROOK ]; let fileAxis, heightAxis, rankAxis; let whiteRankBack, whiteRankPawn, blackRankBack, blackRankPawn; switch(gameState.upAxis) { case 'x': fileAxis = 'z'; heightAxis = 'x'; rankAxis = 'y'; break; case 'z': fileAxis = 'x'; heightAxis = 'z'; rankAxis = 'y'; break; case 'y': default: fileAxis = 'x'; heightAxis = 'y'; rankAxis = 'z'; break;} let rankLimit = BOARD_SIZE; whiteRankBack = 0; whiteRankPawn = 1; blackRankBack = rankLimit - 1; blackRankPawn = rankLimit - 2; if (rankLimit < 2) { console.warn('Board is too small to fit both sides on separate ranks!'); return; } backRankOrder.forEach((type, fileIndex) => { const h = isRandomHeight ? Math.floor(Math.random() * maxHeight) : whiteHeight; const coords = { [fileAxis]: fileIndex, [heightAxis]: h, [rankAxis]: whiteRankBack }; if (coords[rankAxis] < 0 || coords[rankAxis] >= rankLimit || coords[heightAxis] < 0 || coords[heightAxis] >= maxHeight) return; placePiece(type, COLORS.WHITE, coords.x, coords.y, coords.z); }); for (let fileIndex = 0; fileIndex < BOARD_SIZE; fileIndex++) { const h = isRandomHeight ? Math.floor(Math.random() * maxHeight) : whiteHeight; const coords = { [fileAxis]: fileIndex, [heightAxis]: h, [rankAxis]: whiteRankPawn }; if (coords[rankAxis] < 0 || coords[rankAxis] >= rankLimit || coords[heightAxis] < 0 || coords[heightAxis] >= maxHeight) continue; if (isRandomHeight && getPieceAt(coords.x, coords.y, coords.z)) { let found=false; for(let dh=1;dh<maxHeight;dh++){let tH=(h+dh)%maxHeight;coords[heightAxis]=tH;if(!getPieceAt(coords.x,coords.y,coords.z)){found=true;break;}tH=(h-dh+maxHeight)%maxHeight;coords[heightAxis]=tH;if(!getPieceAt(coords.x,coords.y,coords.z)){found=true;break;}} if(!found)console.warn("Could not place random white pawn");} placePiece(PIECE_TYPES.PAWN, COLORS.WHITE, coords.x, coords.y, coords.z); } backRankOrder.forEach((type, fileIndex) => { const h = isRandomHeight ? Math.floor(Math.random() * maxHeight) : blackHeight; const coords = { [fileAxis]: fileIndex, [heightAxis]: h, [rankAxis]: blackRankBack }; if (coords[rankAxis] < 0 || coords[rankAxis] >= rankLimit || coords[heightAxis] < 0 || coords[heightAxis] >= maxHeight) return; placePiece(type, COLORS.BLACK, coords.x, coords.y, coords.z); }); for (let fileIndex = 0; fileIndex < BOARD_SIZE; fileIndex++) { const h = isRandomHeight ? Math.floor(Math.random() * maxHeight) : blackHeight; const coords = { [fileAxis]: fileIndex, [heightAxis]: h, [rankAxis]: blackRankPawn }; if (coords[rankAxis] < 0 || coords[rankAxis] >= rankLimit || coords[heightAxis] < 0 || coords[heightAxis] >= maxHeight) continue; if (isRandomHeight && getPieceAt(coords.x, coords.y, coords.z)) { let found=false; for(let dh=1;dh<maxHeight;dh++){let tH=(h+dh)%maxHeight;coords[heightAxis]=tH;if(!getPieceAt(coords.x,coords.y,coords.z)){found=true;break;}tH=(h-dh+maxHeight)%maxHeight;coords[heightAxis]=tH;if(!getPieceAt(coords.x,coords.y,coords.z)){found=true;break;}} if(!found)console.warn("Could not place random black pawn");} placePiece(PIECE_TYPES.PAWN, COLORS.BLACK, coords.x, coords.y, coords.z); } }
        function placePiece(type, color, x, y, z) { if (!isValidCoordinate(x, y, z)) { console.error(`INVALID Place: ${type} ${color} at ${x},${y},${z}`); return; } try { if (!boardState[x]) boardState[x] = []; if (!boardState[x][y]) boardState[x][y] = Array(gameState.maxHeight).fill(null); if (boardState[x][y][z] !== null && boardState[x][y][z] !== undefined) { console.warn(`Setup collision: Overwriting piece at ${x},${y},${z}`);} boardState[x][y][z] = { type, color, mesh: null, hasMoved: false }; if (type === PIECE_TYPES.KING) { gameState.kingPositions[color] = { x, y, z }; } } catch (e) { console.error(`Error placing piece at [${x}][${y}][${z}]`, e); } }
        function setupPieceMeshes() { if (!helvetikerFont && Object.values(PIECE_TYPES).some(t => t !== PIECE_TYPES.PAWN)) { return; } pieceMeshes.forEach(mesh => scene.remove(mesh)); pieceMeshes = []; for (let x_coord = 0; x_coord < BOARD_SIZE; x_coord++) { for (let y_coord = 0; y_coord < BOARD_SIZE; y_coord++) { for (let z_coord = 0; z_coord < gameState.maxHeight; z_coord++) { const pieceInfo = getPieceAt(x_coord, y_coord, z_coord); if (pieceInfo) { const mesh = createPieceMesh(pieceInfo.type, pieceInfo.color, x_coord, y_coord, z_coord, true); pieceInfo.mesh = mesh; scene.add(mesh); pieceMeshes.push(mesh); } } } } }
        function createPieceMesh(type, color, x, y, z, isGamePiece = true) { let geometry; const scale = 0.7; let pieceLabel = ''; let bodyMaterial = MATERIALS[color].clone(); let baseMaterial = null; let isRoyal = (type === PIECE_TYPES.KING || type === PIECE_TYPES.QUEEN); switch(type) { case PIECE_TYPES.PAWN: geometry = new THREE.BoxGeometry(VOXEL_SIZE*scale*0.8,VOXEL_SIZE*scale*0.8,VOXEL_SIZE*scale*0.8); pieceLabel='P'; break; case PIECE_TYPES.ROOK: geometry = new THREE.BoxGeometry(VOXEL_SIZE*scale*0.9,VOXEL_SIZE*scale*1.4,VOXEL_SIZE*scale*0.9); pieceLabel='R'; break; case PIECE_TYPES.KNIGHT: const gK=new THREE.Group(); const mK=new THREE.Mesh(new THREE.BoxGeometry(VOXEL_SIZE*scale*0.8,VOXEL_SIZE*scale*1.2,VOXEL_SIZE*scale*0.8)); const hK=new THREE.Mesh(new THREE.BoxGeometry(VOXEL_SIZE*scale*0.8,VOXEL_SIZE*scale*0.6,VOXEL_SIZE*scale*0.6)); hK.position.set(0,VOXEL_SIZE*scale*0.3,VOXEL_SIZE*scale*0.4); gK.add(mK); gK.add(hK); geometry=gK; pieceLabel='N'; break; case PIECE_TYPES.BISHOP: geometry = new THREE.ConeGeometry(VOXEL_SIZE*scale*0.5,VOXEL_SIZE*scale*1.5,4); geometry.rotateY(Math.PI/4); pieceLabel='B'; break; case PIECE_TYPES.QUEEN: geometry = new THREE.SphereGeometry(VOXEL_SIZE*scale*0.6,16,16); pieceLabel='Q'; bodyMaterial=MATERIALS.ROYAL_WHITE.clone(); baseMaterial=MATERIALS.ROYAL_BASE_WHITE.clone(); break; case PIECE_TYPES.KING: geometry = new THREE.BoxGeometry(VOXEL_SIZE*scale,VOXEL_SIZE*scale*1.6,VOXEL_SIZE*scale); pieceLabel='K'; bodyMaterial=MATERIALS.ROYAL_WHITE.clone(); baseMaterial=MATERIALS.ROYAL_BASE_WHITE.clone(); break; default: geometry = new THREE.BoxGeometry(VOXEL_SIZE*scale,VOXEL_SIZE*scale,VOXEL_SIZE*scale); pieceLabel='?';} if (isRoyal && color === COLORS.BLACK) { bodyMaterial=MATERIALS.ROYAL_BLACK.clone(); baseMaterial=MATERIALS.ROYAL_BASE_BLACK.clone(); } let baseMesh; if (geometry instanceof THREE.Group) { baseMesh=geometry; baseMesh.children.forEach(c=>{if(c instanceof THREE.Mesh) c.material=bodyMaterial;}); } else { baseMesh = new THREE.Mesh(geometry, bodyMaterial); } let royalBaseMesh = null; if (isRoyal && baseMaterial) { const bR=VOXEL_SIZE*scale*0.6; const bH=VOXEL_SIZE*0.1; const bG=new THREE.CylinderGeometry(bR,bR,bH,16); royalBaseMesh=new THREE.Mesh(bG,baseMaterial); let bodyHForBase=VOXEL_SIZE*scale*(type===PIECE_TYPES.KING?1.6:0.6*2); royalBaseMesh.position.y = -bodyHForBase*0.5+bH*0.5-0.01; } let finalObject = new THREE.Group(); finalObject.add(baseMesh); if(royalBaseMesh) finalObject.add(royalBaseMesh); if (helvetikerFont && pieceLabel !== '?') { const textGeo = new THREE.TextGeometry(pieceLabel, { font: helvetikerFont, size: VOXEL_SIZE*0.4, height: 0.05 }); textGeo.computeBoundingBox(); const textW = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x; const textMesh = new THREE.Mesh(textGeo, color === COLORS.WHITE ? MATERIALS.LABEL_BLACK : MATERIALS.LABEL_WHITE); let pieceH = VOXEL_SIZE*scale; if (geometry instanceof THREE.BoxGeometry) pieceH = geometry.parameters.height; else if (geometry instanceof THREE.ConeGeometry) pieceH = geometry.parameters.height; else if (geometry instanceof THREE.SphereGeometry) pieceH = geometry.parameters.radius*2; else if (geometry instanceof THREE.Group) { const mBody = geometry.children.find(c=>c instanceof THREE.Mesh && c.geometry instanceof THREE.BoxGeometry); if(mBody)pieceH=mBody.geometry.parameters.height;} textMesh.position.set(-textW/2, pieceH*0.5+(royalBaseMesh?0.05:0.1),0); finalObject.add(textMesh); } switch(gameState.upAxis) { case 'x': finalObject.rotation.set(0,0,-Math.PI/2); break; case 'z': finalObject.rotation.set(Math.PI/2,0,0); break; default: break; } finalObject.position.copy(gridToWorld(x,y,z)); finalObject.userData = { type, color, isUnderAttack: false, isThreatening: false }; if (isGamePiece) { finalObject.userData.x=x; finalObject.userData.y=y; finalObject.userData.z=z; finalObject.userData.isPiece=true; } else { finalObject.userData.isCapturedDisplay=true; } return finalObject; }
        function gridToWorld(x,y,z){const hH=gameState.maxHeight/2.0;return new THREE.Vector3((x-HALF_BOARD_XZ+.5)*VOXEL_SIZE,(y-hH+.5)*VOXEL_SIZE,(z-HALF_BOARD_XZ+.5)*VOXEL_SIZE);}
        function worldToGrid(wP){const hH=gameState.maxHeight/2.0;return{x:Math.floor(wP.x/VOXEL_SIZE+HALF_BOARD_XZ),y:Math.floor(wP.y/VOXEL_SIZE+hH),z:Math.floor(wP.z/VOXEL_SIZE+HALF_BOARD_XZ)};}
        function isValidCoordinate(x,y,z){const c={x,y,z};let hA=gameState.upAxis,fA1,fA2;if(hA==='x'){fA1='y';fA2='z';}else if(hA==='z'){fA1='x';fA2='y';}else{fA1='x';fA2='z';}return c[hA]>=0&&c[hA]<gameState.maxHeight&&c[fA1]>=0&&c[fA1]<BOARD_SIZE&&c[fA2]>=0&&c[fA2]<BOARD_SIZE;}
        function getPieceAt(x,y,z){if(!isValidCoordinate(x,y,z))return null;try{return boardState[x]?.[y]?.[z]||null;}catch(e){return null;}}
        function setupAxisLabels(){axisLabelMeshes.forEach(m=>scene.remove(m));axisLabelMeshes=[];if(!helvetikerFont)return;const lX=['A','B','C','D','E','F','G','H'],lY=['I','II','III','IV','V','VI','VII','VIII'].slice(0,gameState.maxHeight),lZ=['1','2','3','4','5','6','7','8'];const sZ=.3,hT=.02,oF=.7;const tM=MATERIALS.AXIS_LABEL.clone();const hHW=gameState.maxHeight*VOXEL_SIZE/2.0,hBW=HALF_BOARD_XZ*VOXEL_SIZE;const mC={x:-hBW,y:-hHW,z:-hBW};for(let i=0;i<BOARD_SIZE;i++){const gX=new THREE.TextGeometry(lX[i],{font:helvetikerFont,size:sZ,height:hT});gX.computeBoundingBox();const cX=(gX.boundingBox.max.x-gX.boundingBox.min.x)*.5;const mX=new THREE.Mesh(gX,tM);mX.position.set((i-HALF_BOARD_XZ+.5)*VOXEL_SIZE-cX,mC.y-oF,mC.z-oF);scene.add(mX);axisLabelMeshes.push(mX);const gZ=new THREE.TextGeometry(lZ[i],{font:helvetikerFont,size:sZ,height:hT});gZ.computeBoundingBox();const cZ=(gZ.boundingBox.max.x-gZ.boundingBox.min.x)*.5;const mZ=new THREE.Mesh(gZ,tM.clone());mZ.position.set(mC.x-oF,mC.y-oF,(i-HALF_BOARD_XZ+.5)*VOXEL_SIZE-cZ);mZ.rotation.y=Math.PI/2;scene.add(mZ);axisLabelMeshes.push(mZ);}for(let i=0;i<gameState.maxHeight;i++){const lT=lY[i]||(i+1).toString();const gY=new THREE.TextGeometry(lT,{font:helvetikerFont,size:sZ,height:hT});gY.computeBoundingBox();const cY=(gY.boundingBox.max.y-gY.boundingBox.min.y)*.5;const mY=new THREE.Mesh(gY,tM.clone());mY.position.set(mC.x-oF,i*VOXEL_SIZE-hHW+.5*VOXEL_SIZE-cY,mC.z-oF);mY.rotation.y=Math.PI/2;scene.add(mY);axisLabelMeshes.push(mY);}}
        function setupInteraction(){window.addEventListener('resize',onWindowResize,false);renderer.domElement.addEventListener('click',onClick,false);}
        function onWindowResize(){if(camera){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();}if(renderer)renderer.setSize(window.innerWidth,window.innerHeight);}
        function onClick(e){e.preventDefault();if(gameState.gameStatus==='checkmate'||gameState.gameStatus==='stalemate'||gameState.gameStatus==='waiting'||gameState.isAiTurn)return;mouse.x=(e.clientX/window.innerWidth)*2-1;mouse.y=-(e.clientY/window.innerHeight)*2+1;raycaster.setFromCamera(mouse,camera);const hI=raycaster.intersectObjects(validMoveMeshes,true);const pI=raycaster.intersectObjects(pieceMeshes,true);let cHD=null,cPD=null;if(hI.length>0){let o=hI[0].object;while(o&&!o.userData.isHighlight&&o.parent!==scene)o=o.parent;if(o&&o.userData.isHighlight)cHD=o.userData;}if(!cHD&&pI.length>0){let o=pI[0].object;while(o&&!(o.userData.isPiece||o.userData.isCapturedDisplay)&&o.parent!==scene)o=o.parent;if(o&&o.userData.isPiece)cPD={...o.userData,mesh:o};}if(selectedPiece){if(cHD){movePiece(selectedPiece.x,selectedPiece.y,selectedPiece.z,cHD.targetX,cHD.targetY,cHD.targetZ,cHD.isEnPassant);deselectPiece();}else if(cPD&&cPD.x===selectedPiece.x&&cPD.y===selectedPiece.y&&cPD.z===selectedPiece.z){deselectPiece();}else if(cPD&&cPD.color===gameState.currentPlayer){playSound('select');deselectPiece();selectPiece(cPD.x,cPD.y,cPD.z);}else{deselectPiece();}}else{if(cPD&&cPD.color===gameState.currentPlayer){playSound('select');selectPiece(cPD.x,cPD.y,cPD.z);}}}
        function selectPiece(x,y,z){const pI=getPieceAt(x,y,z);if(!pI||pI.color!==gameState.currentPlayer||gameState.gameStatus==='checkmate'||gameState.isAiTurn)return;const prevSelMesh=selectedPiece?selectedPiece.mesh:null;selectedPiece={x,y,z,pieceInfo:pI,mesh:pI.mesh};if(prevSelMesh&&prevSelMesh!==pI.mesh){applyPieceVisuals(prevSelMesh);}applyPieceVisuals(pI.mesh);const lM=calculateLegalMoves(pI,x,y,z);highlightValidMoves(lM);drawGhostLines();}
        function deselectPiece(){const prevSelMesh=selectedPiece?selectedPiece.mesh:null;selectedPiece=null;if(prevSelMesh){applyPieceVisuals(prevSelMesh);}clearHighlights();drawGhostLines();}
        function applyPieceVisuals(mOG){if(!mOG||!mOG.userData||!mOG.userData.isPiece)return;const pUD=mOG.userData;const pI=getPieceAt(pUD.x,pUD.y,pUD.z);if(!pI){return;}const iK=pI.type===PIECE_TYPES.KING;const iQ=pI.type===PIECE_TYPES.QUEEN;const pC=pI.color;const iCSel=selectedPiece&&selectedPiece.mesh===mOG;const iCKOCT=iK&&pC===gameState.currentPlayer&&isInCheck(pC,boardState);let tBM=null,tBsM=null;let isOv=false;const storeOrig=(o)=>{if(o instanceof THREE.Mesh&&!(o.geometry instanceof THREE.TextGeometry)){if(o.geometry instanceof THREE.CylinderGeometry){if(!o.userData.originalBaseMaterial)o.userData.originalBaseMaterial=o.material.clone();}else{if(!o.userData.originalMaterial)o.userData.originalMaterial=o.material.clone();}}else if(o instanceof THREE.Group){o.children.forEach(c=>storeOrig(c));}};if(iCKOCT){storeOrig(mOG);tBM=MATERIALS.KING_CHECK.clone();isOv=true;}else if(iCSel){storeOrig(mOG);tBM=MATERIALS.SELECTED.clone();isOv=true;}else if(pUD.isUnderAttack){storeOrig(mOG);tBM=MATERIALS.PIECE_STATE_UNDER_ATTACK.clone();isOv=true;}else if(pUD.isThreatening){storeOrig(mOG);tBM=MATERIALS.PIECE_STATE_THREATENING.clone();isOv=true;}else{if(pUD.originalMaterial){tBM=pUD.originalMaterial;delete pUD.originalMaterial;}else{tBM=MATERIALS[pC==COLORS.WHITE&&(iK||iQ)?'ROYAL_WHITE':pC==COLORS.BLACK&&(iK||iQ)?'ROYAL_BLACK':pC].clone();}if(iK||iQ){if(pUD.originalBaseMaterial){tBsM=pUD.originalBaseMaterial;delete pUD.originalBaseMaterial;}else{tBsM=MATERIALS[pC===COLORS.WHITE?'ROYAL_BASE_WHITE':'ROYAL_BASE_BLACK'].clone();}}}if((iK||iQ)&&isOv&&!tBsM){tBsM=(pUD.originalBaseMaterial||MATERIALS[pC===COLORS.WHITE?'ROYAL_BASE_WHITE':'ROYAL_BASE_BLACK']).clone();}const applyMat=(o,bM,bsM)=>{if(o instanceof THREE.Mesh&&!(o.geometry instanceof THREE.TextGeometry)){if(o.geometry instanceof THREE.CylinderGeometry&&bsM){o.material=bsM;}else{o.material=bM;}}else if(o instanceof THREE.Group){o.children.forEach(c=>applyMat(c,bM,bsM));}};applyMat(mOG,tBM,tBsM);}
        function updateAllPieceTacticalVisuals(){if(!boardState||pieceMeshes.length===0)return;pieceMeshes.forEach(m=>{if(m.userData&&m.userData.isPiece){m.userData.isUnderAttack=false;m.userData.isThreatening=false;}});for(let xC=0;xC<BOARD_SIZE;xC++){for(let yC=0;yC<BOARD_SIZE;yC++){for(let zC=0;zC<gameState.maxHeight;zC++){const cPI=getPieceAt(xC,yC,zC);if(cPI&&cPI.mesh){const cM=cPI.mesh;const oC=(cPI.color===COLORS.WHITE)?COLORS.BLACK:COLORS.WHITE;if(isSquareAttacked(xC,yC,zC,oC,boardState)){cM.userData.isUnderAttack=true;}const pM=_calculatePseudoLegalMoves(cPI,xC,yC,zC,boardState);for(const mv of pM){if(mv.isCapture){const tP=getPieceAt(mv.x,mv.y,mv.z);if(tP&&tP.color===oC){cM.userData.isThreatening=true;break;}}}}}}}pieceMeshes.forEach(m=>{if(m.userData&&m.userData.isPiece){applyPieceVisuals(m);}});if(selectedPiece&&selectedPiece.mesh){applyPieceVisuals(selectedPiece.mesh);}}
        function highlightValidMoves(mvs){clearHighlights();const hG=new THREE.SphereGeometry(VOXEL_SIZE*.2,8,8);mvs.forEach(m=>{const iC=m.isCapture||m.isEnPassant;const mM=(gameState.highlightCaptures&&iC)?MATERIALS.CAPTURE_MOVE.clone():MATERIALS.VALID_MOVE.clone();const me=new THREE.Mesh(hG,mM);me.position.copy(gridToWorld(m.x,m.y,m.z));me.userData={isHighlight:true,targetX:m.x,targetY:m.y,targetZ:m.z,isEnPassant:!!m.isEnPassant,isCapture:iC};scene.add(me);validMoveMeshes.push(me);});}
        function clearHighlights(){validMoveMeshes.forEach(m=>scene.remove(m));validMoveMeshes=[];}
        function copyBoardState(sBS){const nBS=[];for(let x=0;x<BOARD_SIZE;x++){nBS[x]=[];for(let y=0;y<BOARD_SIZE;y++){nBS[x][y]=[];for(let z=0;z<gameState.maxHeight;z++){const p=sBS[x]?.[y]?.[z];if(p)nBS[x][y][z]={type:p.type,color:p.color,hasMoved:p.hasMoved};else nBS[x][y][z]=null;}}}return nBS;}
        function _calculatePseudoLegalMoves(pieceInfo,x,y,z,currentBoardState){const moves=[];const{type,color,hasMoved}=pieceInfo;const getPAL=(lx,ly,lz)=>{if(!isValidCoordinate(lx,ly,lz))return null;try{return currentBoardState[lx]?.[ly]?.[lz]||null;}catch(e){return null;}};const addSMvs=(dx,dy,dz)=>{let mS=Math.max(BOARD_SIZE,gameState.maxHeight);for(let i=1;i<mS;i++){const nx=x+i*dx,ny=y+i*dy,nz=z+i*dz;if(!isValidCoordinate(nx,ny,nz))break;const tP=getPAL(nx,ny,nz);if(tP===null){moves.push({x:nx,y:ny,z:nz,isCapture:false});}else{if(tP.color!==color){moves.push({x:nx,y:ny,z:nz,isCapture:true});}break;}}};const addSingleMove=(nX,nY,nZ,iCO=false,iEP=false)=>{if(!isValidCoordinate(nX,nY,nZ))return;const tP=getPAL(nX,nY,nZ);const iC=!!tP&&tP.color!==color;if(tP===null){if(!iCO){moves.push({x:nX,y:nY,z:nZ,isCapture:false,isEnPassant:iEP});}}else if(iC){moves.push({x:nX,y:nY,z:nZ,isCapture:true,isEnPassant:iEP});}};switch(type){case PIECE_TYPES.PAWN:const oM=[{dx:1,dy:0,dz:0},{dx:-1,dy:0,dz:0},{dx:0,dy:1,dz:0},{dx:0,dy:-1,dz:0},{dx:0,dy:0,dz:1},{dx:0,dy:0,dz:-1}];oM.forEach(m=>{const nX=x+m.dx,nY=y+m.dy,nZ=z+m.dz;if(isValidCoordinate(nX,nY,nZ)&&getPAL(nX,nY,nZ)===null){moves.push({x:nX,y:nY,z:nZ,isCapture:false});}});const uCD=[[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1],[0,1,1],[0,1,-1],[0,-1,1],[0,-1,-1]];uCD.forEach(d=>{const nX=x+d[0],nY=y+d[1],nZ=z+d[2];if(isValidCoordinate(nX,nY,nZ)){const t=getPAL(nX,nY,nZ);if(t!==null&&t.color!==color){moves.push({x:nX,y:nY,z:nZ,isCapture:true});}}});if(!hasMoved){const axes=['x','y','z'];axes.forEach(axis=>{let dir={x:0,y:0,z:0};dir[axis]=1;const m1={x:x+dir.x,y:y+dir.y,z:z+dir.z};const e1={x:x+2*dir.x,y:y+2*dir.y,z:z+2*dir.z};if(isValidCoordinate(e1.x,e1.y,e1.z)&&getPAL(m1.x,m1.y,m1.z)===null&&getPAL(e1.x,e1.y,e1.z)===null){moves.push({x:e1.x,y:e1.y,z:e1.z,isCapture:false});}dir[axis]=-1;const m2={x:x+dir.x,y:y+dir.y,z:z+dir.z};const e2={x:x+2*dir.x,y:y+2*dir.y,z:z+2*dir.z};if(isValidCoordinate(e2.x,e2.y,e2.z)&&getPAL(m2.x,m2.y,m2.z)===null&&getPAL(e2.x,e2.y,e2.z)===null){moves.push({x:e2.x,y:e2.y,z:e2.z,isCapture:false});}}); }const last=gameState.lastMove;if(last&&last.pieceType===PIECE_TYPES.PAWN&&last.color!==color&&last.skipped){const axes=['x','y','z'];axes.forEach(axis=>{if(Math.abs(last.to[axis]-last.from[axis])===2){if({x,y,z}[axis]===last.to[axis]){const fA=axes.filter(ax=>ax!==axis);const cC={x,y,z};const cOD={x:last.to.x,y:last.to.y,z:last.to.z};const aF=fA.some(fa=>Math.abs(cC[fa]-cOD[fa])===1&&fA.every(fb=>fb===fa||cC[fb]===cOD[fb]));if(aF){addSingleMove(last.skipped.x,last.skipped.y,last.skipped.z,false,true);}}}});}break;case PIECE_TYPES.ROOK:addSMvs(1,0,0);addSMvs(-1,0,0);addSMvs(0,1,0);addSMvs(0,-1,0);addSMvs(0,0,1);addSMvs(0,0,-1);break;case PIECE_TYPES.KNIGHT:const kM=[[1,2,0],[1,-2,0],[-1,2,0],[-1,-2,0],[2,1,0],[2,-1,0],[-2,1,0],[-2,-1,0],[1,0,2],[1,0,-2],[-1,0,2],[-1,0,-2],[2,0,1],[2,0,-1],[-2,0,1],[-2,0,-1],[0,1,2],[0,1,-2],[0,-1,2],[0,-1,-2],[0,2,1],[0,2,-1],[0,-2,1],[0,-2,-1]];kM.forEach(m=>{addSingleMove(x+m[0],y+m[1],z+m[2]);});break;case PIECE_TYPES.BISHOP:addSMvs(1,1,0);addSMvs(1,-1,0);addSMvs(-1,1,0);addSMvs(-1,-1,0);addSMvs(1,0,1);addSMvs(1,0,-1);addSMvs(-1,0,1);addSMvs(-1,0,-1);addSMvs(0,1,1);addSMvs(0,1,-1);addSMvs(0,-1,1);addSMvs(0,-1,-1);break;case PIECE_TYPES.QUEEN:addSMvs(1,0,0);addSMvs(-1,0,0);addSMvs(0,1,0);addSMvs(0,-1,0);addSMvs(0,0,1);addSMvs(0,0,-1);addSMvs(1,1,0);addSMvs(1,-1,0);addSMvs(-1,1,0);addSMvs(-1,-1,0);addSMvs(1,0,1);addSMvs(1,0,-1);addSMvs(-1,0,1);addSMvs(-1,0,-1);addSMvs(0,1,1);addSMvs(0,1,-1);addSMvs(0,-1,1);addSMvs(0,-1,-1);break;case PIECE_TYPES.KING:for(let dx=-1;dx<=1;dx++){for(let dy=-1;dy<=1;dy++){for(let dz=-1;dz<=1;dz++){if(dx===0&&dy===0&&dz===0)continue;addSingleMove(x+dx,y+dy,z+dz);}}}break;}return moves;}
        function isSquareAttacked(x,y,z,aC,cBS){for(let ax=0;ax<BOARD_SIZE;ax++){for(let ay=0;ay<BOARD_SIZE;ay++){for(let azC=0;azC<gameState.maxHeight;azC++){const aP=cBS[ax]?.[ay]?.[azC];if(aP&&aP.color===aC){const att=_calculatePseudoLegalMoves(aP,ax,ay,azC,cBS);for(const atk of att){if(atk.x===x&&atk.y===y&&atk.z===z)return true;}}}}}return false;}
        function isInCheck(pC,cBS){const kP=gameState.kingPositions[pC];if(!kP||!isValidCoordinate(kP.x,kP.y,kP.z))return false;const oC=(pC===COLORS.WHITE)?COLORS.BLACK:COLORS.WHITE;return isSquareAttacked(kP.x,kP.y,kP.z,oC,cBS);}
        function calculateLegalMoves(pI,x,y,z){const lM=[];const pLM=_calculatePseudoLegalMoves(pI,x,y,z,boardState);const pC=pI.color;const oKP=gameState.kingPositions[pC];for(const mv of pLM){const tBS=copyBoardState(boardState);const pTM=tBS[x]?.[y]?.[z];if(!pTM)continue;if(mv.isEnPassant&&pI.type===PIECE_TYPES.PAWN){const last=gameState.lastMove;if(last?.skipped&&last.skipped.x===mv.x&&last.skipped.y===mv.y&&last.skipped.z===mv.z&&last.to){if(tBS[last.to.x]?.[last.to.y])tBS[last.to.x][last.to.y][last.to.z]=null;}}else{if(tBS[mv.x]?.[mv.y])tBS[mv.x][mv.y][mv.z]=null;}if(tBS[mv.x]?.[mv.y])tBS[mv.x][mv.y][mv.z]=pTM;if(tBS[x]?.[y])tBS[x][y][z]=null;let tKP=oKP?{...oKP}:null;if(pTM.type===PIECE_TYPES.KING){tKP={x:mv.x,y:mv.y,z:mv.z};}if(tKP){gameState.kingPositions[pC]=tKP;if(!isInCheck(pC,tBS)){lM.push(mv);}}}gameState.kingPositions[pC]=oKP;return lM;}
        function getAllLegalMoves(pC){let aM=[];for(let xC=0;xC<BOARD_SIZE;xC++){for(let yC=0;yC<BOARD_SIZE;yC++){for(let zC=0;zC<gameState.maxHeight;zC++){const pI=getPieceAt(xC,yC,zC);if(pI&&pI.color===pC){const pMs=calculateLegalMoves(pI,xC,yC,zC);aM.push(...pMs);}}}}return aM;}
        function movePiece(fX,fY,fZ,tX,tY,tZ,iEP=false){const mP=gameState.currentPlayer;const mPI=getPieceAt(fX,fY,fZ);if(!mPI||gameState.gameStatus==='checkmate'||gameState.gameStatus==='stalemate')return;const tBS=copyBoardState(boardState);const pTM=tBS[fX]?.[fY]?.[fZ];if(!pTM)return;if(iEP&&mPI.type===PIECE_TYPES.PAWN){const last=gameState.lastMove;if(last?.skipped&&last.skipped.x===tX&&last.skipped.y===tY&&last.skipped.z===tZ&&last.to){if(tBS[last.to.x]?.[last.to.y])tBS[last.to.x][last.to.y][last.to.z]=null;}}else{if(tBS[tX]?.[tY])tBS[tX][tY][tZ]=null;}if(tBS[tX]?.[tY])tBS[tX][tY][tZ]=pTM;if(tBS[fX]?.[fY])tBS[fX][fY][fZ]=null;let oKP=gameState.kingPositions[mP];let tKP=oKP?{...oKP}:null;if(pTM.type===PIECE_TYPES.KING)tKP={x:tX,y:tY,z:tZ};if(tKP){gameState.kingPositions[mP]=tKP;if(isInCheck(mP,tBS)){console.log("Invalid move: Cannot move into check.");gameState.kingPositions[mP]=oKP;return;}gameState.kingPositions[mP]=oKP;}let cPD=null;let cPP={x:tX,y:tY,z:tZ};if(iEP&&mPI.type===PIECE_TYPES.PAWN){const last=gameState.lastMove;if(last&&last.skipped&&last.skipped.x===tX&&last.skipped.y===tY&&last.skipped.z===tZ&&last.to){cPP=last.to;const epTI=getPieceAt(cPP.x,cPP.y,cPP.z);if(epTI)cPD={type:epTI.type,color:epTI.color};else{console.warn("EP no piece",cPP);iEP=false;}}else{console.error("EP flag error");iEP=false;}}if(!iEP){const tI=getPieceAt(tX,tY,tZ);if(tI){if(tI.color===mPI.color)return;cPD={type:tI.type,color:tI.color};}}if(cPD){handleCapture(cPD,cPP,mP);if(gameState.gameStatus==='checkmate'){updateAllPieceTacticalVisuals();drawConflictRays();updateInfoPanel();return;}}const axes=['x','y','z'];let tSA=null;axes.forEach(axis=>{if(mPI.type===PIECE_TYPES.PAWN&&!mPI.hasMoved&&Math.abs({x:tX-fX,y:tY-fY,z:tZ-fZ}[axis])===2){const fA=axes.filter(ax=>ax!==axis);if(fA.every(ax=>Math.abs({x:tX-fX,y:tY-fY,z:tZ-fZ}[ax])===0)){tSA=axis;}}});if(boardState[tX]?.[tY])boardState[tX][tY][tZ]=mPI;else console.warn("Invalid write",tX,tY,tZ);if(boardState[fX]?.[fY])boardState[fX][fY][fZ]=null;mPI.hasMoved=true;if(mPI.type===PIECE_TYPES.KING)gameState.kingPositions[mPI.color]={x:tX,y:tY,z:tZ};if(mPI.mesh){mPI.mesh.position.copy(gridToWorld(tX,tY,tZ));mPI.mesh.userData.x=tX;mPI.mesh.userData.y=tY;mPI.mesh.userData.z=tZ;}if(mPI.type===PIECE_TYPES.PAWN&&tSA){let sS={x:fX,y:fY,z:fZ};sS[tSA]=fX+(({x:tX,y:tY,z:tZ}[tSA])>({x:fX,y:fY,z:fZ}[tSA])?1:-1);gameState.lastMove={pieceType:mPI.type,color:mPI.color,from:{x:fX,y:fY,z:fZ},to:{x:tX,y:tY,z:tZ},skipped:sS};}else{gameState.lastMove={pieceType:mPI.type,color:mPI.color,from:{x:fX,y:fY,z:fZ},to:{x:tX,y:tY,z:tZ},skipped:null};}const iTSJ=!!tSA;handlePromotion(mPI,tX,tY,tZ,iTSJ);gameState.currentPlayer=(gameState.currentPlayer===COLORS.WHITE)?COLORS.BLACK:COLORS.WHITE;updateGameStatusAndCheckEnd();drawGhostLines();drawSupportLines();updateAllPieceTacticalVisuals();drawConflictRays();updateInfoPanel();maybeTriggerAiMove();}
        function handleCapture(cPD,cPP,cP){console.log(`${cP} captures ${cPD.color} ${cPD.type} at ${cPP.x},${cPP.y},${cPP.z}`);playSound('capture');const aCI=getPieceAt(cPP.x,cPP.y,cPP.z);if(aCI&&aCI.mesh){const mTR=pieceMeshes.find(m=>m===aCI.mesh);if(mTR){scene.remove(mTR);const mI=pieceMeshes.indexOf(mTR);if(mI>-1)pieceMeshes.splice(mI,1);}}if(boardState[cPP.x]?.[cPP.y]){boardState[cPP.x][cPP.y][cPP.z]=null;}const pV=PIECE_VALUES[cPD.type]||0;if(cP===COLORS.WHITE){whiteScore+=pV;capturedByWhite.push(cPD);}else{blackScore+=pV;capturedByBlack.push(cPD);}updateCapturedDisplay();if(cPD.type===PIECE_TYPES.KING){gameState.gameStatus='checkmate';gameState.kingPositions[cPD.color]=null;playSound('checkmate');}}
        function handlePromotion(mPI,tX,tY,tZ,iTSJ){const iP=mPI.type===PIECE_TYPES.PAWN;let p=false;if(iP&&!iTSJ){const iW=mPI.color===COLORS.WHITE;let rA;switch(gameState.upAxis){case'x':rA='y';break;case'z':rA='y';break;case'y':default:rA='z';break;}const tCs={x:tX,y:tY,z:tZ};const pRC=iW?BOARD_SIZE-1:0;if(tCs[rA]===pRC){promotePawn(tX,tY,tZ,mPI);p=true;}}if(p&&gameState.lastMove){gameState.lastMove.promotedTo=PIECE_TYPES.QUEEN;}}
        function promotePawn(x,y,z,pI){const nT=PIECE_TYPES.QUEEN;const oC=pI.color;const oM=pI.mesh;if(oM){scene.remove(oM);const mI=pieceMeshes.indexOf(oM);if(mI>-1)pieceMeshes.splice(mI,1);}const nPI={type:nT,color:oC,mesh:null,hasMoved:true};const nM=createPieceMesh(nT,oC,x,y,z,true);nPI.mesh=nM;if(boardState[x]?.[y])boardState[x][y][z]=nPI;scene.add(nM);pieceMeshes.push(nM);}
        function updateGameStatusAndCheckEnd(){if(gameState.gameStatus==='checkmate'||gameState.gameStatus==='stalemate')return;const nIC=isInCheck(gameState.currentPlayer,boardState);if(nIC){const lM=getAllLegalMoves(gameState.currentPlayer);if(lM.length===0){gameState.gameStatus='checkmate';const W=(gameState.currentPlayer===COLORS.WHITE)?'Black':'White';playSound('checkmate');setTimeout(()=>alert(`Checkmate! ${W} wins!`),10);}else{gameState.gameStatus='check';playSound('check');}}else{const lM=getAllLegalMoves(gameState.currentPlayer);if(lM.length===0){gameState.gameStatus='stalemate';playSound('move');setTimeout(()=>alert("Stalemate! It's a draw!"),10);}else{gameState.gameStatus='playing';}}}
        function maybeTriggerAiMove(){if(gameState.opponentType!=='human'&&gameState.currentPlayer===gameState.aiColor&&gameState.gameStatus!=='checkmate'&&gameState.gameStatus!=='stalemate'){gameState.isAiTurn=true;deselectPiece();updateInfoPanel();setTimeout(()=>{calculateAiMove(gameState.aiColor);},AI_DELAY);}else{gameState.isAiTurn=false;}}
        function calculateAiMove(aiColor){let cM=null;if(gameState.opponentType==='random'){cM=getRandomMove(aiColor);}else if(gameState.opponentType==='greedy'){cM=getGreedyMove(aiColor);}if(cM){const sP=getPieceAt(cM.from.x,cM.from.y,cM.from.z);if(sP){movePiece(cM.from.x,cM.from.y,cM.from.z,cM.to.x,cM.to.y,cM.to.z,cM.isEnPassant);}else{console.error("AI No piece",cM.from);gameState.isAiTurn=false;}}else{console.log("AI no moves");gameState.isAiTurn=false;}}
        function getRandomMove(aiColor){const allMoves=[];for(let x_iter=0;x_iter<BOARD_SIZE;x_iter++){for(let y_iter=0;y_iter<BOARD_SIZE;y_iter++){for(let z_iter=0;z_iter<gameState.maxHeight;z_iter++){const pieceInfo=getPieceAt(x_iter,y_iter,z_iter);if(pieceInfo&&pieceInfo.color===aiColor){const legalMoves=calculateLegalMoves(pieceInfo,x_iter,y_iter,z_iter);legalMoves.forEach(move=>{allMoves.push({from:{x:x_iter,y:y_iter,z:z_iter},to:{x:move.x,y:move.y,z:move.z},isEnPassant:move.isEnPassant});});}}}}if(allMoves.length===0)return null;return allMoves[Math.floor(Math.random()*allMoves.length)];}
        function getGreedyMove(aiColor){let bestScore=-Infinity;let bestMoves=[];for(let x_iter=0;x_iter<BOARD_SIZE;x_iter++){for(let y_iter=0;y_iter<BOARD_SIZE;y_iter++){for(let z_iter=0;z_iter<gameState.maxHeight;z_iter++){const pieceInfo=getPieceAt(x_iter,y_iter,z_iter);if(pieceInfo&&pieceInfo.color===aiColor){const legalMoves=calculateLegalMoves(pieceInfo,x_iter,y_iter,z_iter);for(const move of legalMoves){const tempBoard=copyBoardState(boardState);const tempPiece=tempBoard[x_iter]?.[y_iter]?.[z_iter];if(!tempPiece)continue;if(move.isEnPassant){const last=gameState.lastMove;if(last?.skipped&&last.skipped.x===move.x&&last.skipped.y===move.y&&last.skipped.z===move.z&&last.to){if(tempBoard[last.to.x]?.[last.to.y])tempBoard[last.to.x][last.to.y][last.to.z]=null;}}else{if(tempBoard[move.x]?.[move.y])tempBoard[move.x][move.y][move.z]=null;}if(tempBoard[move.x]?.[move.y])tempBoard[move.x][move.y][move.z]=tempPiece;if(tempBoard[x_iter]?.[y_iter])tempBoard[x_iter][y_iter][z_iter]=null;const currentScore=evaluatePosition(tempBoard,aiColor);const currentMoveData={from:{x:x_iter,y:y_iter,z:z_iter},to:{x:move.x,y:move.y,z:move.z},isEnPassant:move.isEnPassant};if(currentScore>bestScore){bestScore=currentScore;bestMoves=[currentMoveData];}else if(currentScore===bestScore){bestMoves.push(currentMoveData);}}}}}}if(bestMoves.length===0)return null;return bestMoves[Math.floor(Math.random()*bestMoves.length)];}
        function evaluatePosition(currentBoard,colorToEvaluate){let myMaterial=0;let opponentMaterial=0;for(let x_iter=0;x_iter<BOARD_SIZE;x_iter++){for(let y_iter=0;y_iter<BOARD_SIZE;y_iter++){for(let z_iter=0;z_iter<gameState.maxHeight;z_iter++){const piece=currentBoard[x_iter]?.[y_iter]?.[z_iter];if(piece){const value=PIECE_VALUES[piece.type]||0;if(piece.color===colorToEvaluate){myMaterial+=value;}else{opponentMaterial+=value;}}}}}return myMaterial-opponentMaterial;}
        function updateCapturedDisplay(){capturedWhiteDisplayMeshes.forEach(m=>scene.remove(m));capturedBlackDisplayMeshes.forEach(m=>scene.remove(m));capturedWhiteDisplayMeshes=[];capturedBlackDisplayMeshes=[];let wB=new THREE.Vector3(),bB=new THREE.Vector3();let sA='x';const oA=2.0;const hHW=gameState.maxHeight*VOXEL_SIZE/2.0,hBW=HALF_BOARD_XZ*VOXEL_SIZE;switch(gameState.upAxis){case 'x':wB.set(-hHW,-hBW-oA*VOXEL_SIZE,hBW-.5*VOXEL_SIZE);bB.set(-hHW,-hBW-oA*VOXEL_SIZE,-hBW-VOXEL_SIZE);sA='y';break;case 'z':wB.set(-hBW-oA*VOXEL_SIZE,hBW-.5*VOXEL_SIZE,-hHW);bB.set(-hBW-oA*VOXEL_SIZE,-hBW-VOXEL_SIZE,-hHW);sA='x';break;case 'y':default:wB.set(-hBW-oA*VOXEL_SIZE,-hHW,hBW-.5*VOXEL_SIZE);bB.set(-hBW-oA*VOXEL_SIZE,-hHW,-hBW-1.5*VOXEL_SIZE);sA='x';break;}capturedByWhite.sort((a,b)=>(PIECE_VALUES[b.type]||0)-(PIECE_VALUES[a.type]||0));capturedByBlack.sort((a,b)=>(PIECE_VALUES[b.type]||0)-(PIECE_VALUES[a.type]||0));capturedByWhite.forEach((pD,idx)=>{const cM=createPieceMesh(pD.type,pD.color,0,0,0,false);cM.scale.set(CAPTURED_SCALE,CAPTURED_SCALE,CAPTURED_SCALE);const pos=wB.clone();pos[sA]+=idx*CAPTURED_SPACING;cM.position.copy(pos);scene.add(cM);capturedWhiteDisplayMeshes.push(cM);});capturedByBlack.forEach((pD,idx)=>{const cM=createPieceMesh(pD.type,pD.color,0,0,0,false);cM.scale.set(CAPTURED_SCALE,CAPTURED_SCALE,CAPTURED_SCALE);const pos=bB.clone();pos[sA]+=idx*CAPTURED_SPACING;cM.position.copy(pos);scene.add(cM);capturedBlackDisplayMeshes.push(cM);});}
        function updateInfoPanel(){if(gameState.gameStatus==='waiting'){document.getElementById('status').textContent='Waiting...';return;}const tS=document.getElementById('turn');tS.textContent=(gameState.gameStatus==='checkmate'||gameState.gameStatus==='stalemate')?'--':gameState.currentPlayer.charAt(0).toUpperCase()+gameState.currentPlayer.slice(1);tS.style.fontWeight='bold';tS.style.color=gameState.currentPlayer===COLORS.WHITE?'#eee':'#aaa';document.getElementById('white-score').textContent=whiteScore;document.getElementById('black-score').textContent=blackScore;const sS=document.getElementById('status');let sT='';switch(gameState.gameStatus){case 'playing':sT='Playing';break;case 'check':sT='Check!';break;case 'checkmate':const W=(gameState.currentPlayer===COLORS.WHITE)?'Black':'White';sT=`Checkmate! ${W} wins.`;break;case 'stalemate':sT="Stalemate! Draw.";break;default:sT=gameState.gameStatus;}sS.textContent=sT;sS.className=gameState.gameStatus;sS.style.color=(gameState.gameStatus==='check'||gameState.gameStatus==='checkmate'||gameState.gameStatus==='stalemate')?'#ff8888':'#ffffff';}
        function clearGhostLines(){ghostLines.forEach(l=>scene.remove(l));ghostLines=[];ghostHash.clear();}
        function addGhostLine(fX,fY,fZ,tX,tY,tZ,aC,iC){const s=gridToWorld(fX,fY,fZ),e=gridToWorld(tX,tY,tZ);const d=new THREE.Vector3().subVectors(e,s);const l=d.length();const m=new THREE.Vector3().addVectors(s,e).multiplyScalar(.5);const r=VOXEL_SIZE*(iC?0.06:0.03);const g=new THREE.CylinderGeometry(r,r,l,iC?8:5);let mat;if(iC){mat=(aC===COLORS.WHITE)?MATERIALS.GHOST_LINE_CAPTURE_WHITE.clone():MATERIALS.GHOST_LINE_CAPTURE_BLACK.clone();}else{mat=(aC===COLORS.WHITE)?MATERIALS.GHOST_LINE_NON_CAPTURE_WHITE.clone():MATERIALS.GHOST_LINE_NON_CAPTURE_BLACK.clone();}const cyl=new THREE.Mesh(g,mat);cyl.position.copy(m);cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),d.clone().normalize());scene.add(cyl);ghostLines.push(cyl);}
        function drawGhostLines(){clearGhostLines();if(gameState.attackMode==='none'||!selectedPiece||!selectedPiece.pieceInfo)return;const pI=selectedPiece.pieceInfo;const x=selectedPiece.x,y=selectedPiece.y,z=selectedPiece.z;const aC=pI.color;const mvs=_calculatePseudoLegalMoves(pI,x,y,z,boardState);const cKP=gameState.kingPositions[pI.color];for(const mv of mvs){let iSM=true;if(cKP){const tB=copyBoardState(boardState);const pTM=tB[x]?.[y]?.[z];if(pTM){if(mv.isEnPassant){const last=gameState.lastMove;if(last?.skipped&&last.skipped.x===mv.x&&last.skipped.y===mv.y&&last.skipped.z===mv.z&&last.to){if(tB[last.to.x]?.[last.to.y])tB[last.to.x][last.to.y][last.to.z]=null;}}else{if(tB[mv.x]?.[mv.y])tB[mv.x][mv.y][mv.z]=null;}if(tB[mv.x]?.[mv.y])tB[mv.x][mv.y][mv.z]=pTM;if(tB[x]?.[y])tB[x][y][z]=null;let tKP=pTM.type===PIECE_TYPES.KING?{x:mv.x,y:mv.y,z:mv.z}:{...cKP};gameState.kingPositions[pI.color]=tKP;if(isInCheck(pI.color,tB))iSM=false;gameState.kingPositions[pI.color]=cKP;}}if(!iSM)continue;const key=`${x},${y},${z}->${mv.x},${mv.y},${mv.z}`;if(ghostHash.has(key))continue;ghostHash.add(key);if(gameState.attackMode==='captures'&&!mv.isCapture&&!mv.isEnPassant)continue;addGhostLine(x,y,z,mv.x,mv.y,mv.z,aC,mv.isCapture||mv.isEnPassant);}}
        function clearSupportLines(){supportLines.forEach(l=>scene.remove(l));supportLines=[];supportHash.clear();}
        function addSupportLine(fX,fY,fZ,tX,tY,tZ,pC){const s=gridToWorld(fX,fY,fZ),e=gridToWorld(tX,tY,tZ);const d=new THREE.Vector3().subVectors(e,s);const l=d.length();const m=new THREE.Vector3().addVectors(s,e).multiplyScalar(.5);const r=VOXEL_SIZE*.05;const g=new THREE.CylinderGeometry(r,r,l,6);const mat=(pC===COLORS.WHITE)?MATERIALS.SUPPORT_LINE_WHITE.clone():MATERIALS.SUPPORT_LINE_BLACK.clone();const cyl=new THREE.Mesh(g,mat);cyl.position.copy(m);cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),d.clone().normalize());scene.add(cyl);supportLines.push(cyl);}
        
        // <<< MODIFICATION START: drawSupportLines uses defensive coverage logic >>>
        function drawSupportLines() {
            clearSupportLines();
            if (!gameState.supportLines) { return; }

            for (let x_coord = 0; x_coord < BOARD_SIZE; x_coord++) {
              for (let y_coord = 0; y_coord < BOARD_SIZE; y_coord++) {
                for (let z_coord = 0; z_coord < gameState.maxHeight; z_coord++) {
                  const defendingPieceInfo = getPieceAt(x_coord, y_coord, z_coord);
                  if (!defendingPieceInfo) continue;

                  // Get all squares this piece attacks/covers, even if occupied by a friendly piece for this purpose
                  const coveredSquares = _calculatePseudoLegalMoves(defendingPieceInfo, x_coord, y_coord, z_coord, boardState);

                  for (const cover of coveredSquares) {
                    const defendedPieceInfo = getPieceAt(cover.x, cover.y, cover.z);

                    // If the covered square has a friendly piece (that isn't itself)
                    if (defendedPieceInfo && defendedPieceInfo.color === defendingPieceInfo.color &&
                        !(x_coord === cover.x && y_coord === cover.y && z_coord === cover.z) ) {
                        
                        // For support lines, we are interested if the 'defendingPieceInfo' *could attack* the square
                        // where 'defendedPieceInfo' resides. The 'isCapture' flag in pseudo-legal moves
                        // indicates if it *would be* a capture if an opponent were there.
                        // For Knights and Kings, any pseudo-legal move is an attack.
                        // For Pawns, only their diagonal moves are attacks.
                        // For R, B, Q, any move to an occupied square (if it were an opponent) is an attack.

                        let isAttackingMove = cover.isCapture; // This is true if an *opponent* would be captured
                        if (defendingPieceInfo.type === PIECE_TYPES.KNIGHT || defendingPieceInfo.type === PIECE_TYPES.KING) {
                            isAttackingMove = true; // Knights and Kings always "attack" squares they move to
                        } else if (defendingPieceInfo.type === PIECE_TYPES.PAWN) {
                            // For pawns, support is via diagonal capture threat only
                            // Check if the move (cover) is a diagonal from the pawn's current position
                            const dx = Math.abs(cover.x - x_coord);
                            const dy = Math.abs(cover.y - y_coord);
                            const dz = Math.abs(cover.z - z_coord);
                            const totalDelta = dx + dy + dz;
                             // A single diagonal step will have two non-zero deltas of 1, or one delta of 1 (if restricted)
                             // For 3D, a diagonal capture is usually dx,dy !=0, dz=0 (or permutations) -> totalDelta = 2
                             // Or dx=1, dy=1, dz=1 -> totalDelta = 3
                            isAttackingMove = ( (dx === 1 && dy === 1 && dz === 0) ||
                                                (dx === 1 && dz === 1 && dy === 0) ||
                                                (dy === 1 && dz === 1 && dx === 0) ||
                                                (dx === 1 && dy === 1 && dz === 1) );
                        }
                        // For R, B, Q, if they can slide to a square and hit a piece, that's an attack.
                        // _calculatePseudoLegalMoves's `isCapture` flag is set if it hits an *opponent*.
                        // For showing support to a *friendly* piece, we need to infer if the square is attacked.
                        // The fact that a pseudo-legal move exists to that square is enough for K, N.
                        // For R, B, Q, if a friendly piece is on that square, the slider *would* attack it if it were an enemy.
                        // So the primary condition is just that the target square is on the piece's path.
                        // The `cover.isCapture` in `_calculatePseudoLegalMoves` is set if an *opponent* would be captured.
                        // We need a more general "does this piece attack this square" check.
                        // For simplicity for now: if _calculatePseudoLegalMoves includes a square,
                        // it means the piece exerts influence there.

                        const keyA = `${x_coord},${y_coord},${z_coord}->${cover.x},${cover.y},${cover.z}`;
                        const keyB = `${cover.x},${cover.y},${cover.z}->${x_coord},${y_coord},${z_coord}`;
                        
                        if (!supportHash.has(keyA) && !supportHash.has(keyB)) {
                            supportHash.add(keyA); supportHash.add(keyB);
                            addSupportLine(x_coord, y_coord, z_coord, cover.x, cover.y, cover.z, defendingPieceInfo.color);
                        }
                    }
                  }
                }
              }
            }
        }
        // <<< MODIFICATION END >>>

        function clearConflictRays() { conflictRayMeshes.forEach(l => scene.remove(l)); conflictRayMeshes = []; conflictRayHash.clear(); }
        function addConflictRay(fx, fy, fz, tx, ty, tz, attackerColor) { const start = gridToWorld(fx, fy, fz); const end = gridToWorld(tx, ty, tz); const dir = new THREE.Vector3().subVectors(end, start); const len = dir.length(); const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5); const radius = VOXEL_SIZE * 0.025; const geom = new THREE.CylinderGeometry(radius, radius, len, 6); const mat = (attackerColor === COLORS.WHITE) ? MATERIALS.CONFLICT_RAY_WHITE_ATTACKING.clone() : MATERIALS.CONFLICT_RAY_BLACK_ATTACKING.clone(); const cyl = new THREE.Mesh(geom, mat); cyl.position.copy(mid); cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize()); scene.add(cyl); conflictRayMeshes.push(cyl); }
        function drawConflictRays() { clearConflictRays(); if (!gameState.showConflictRays || !boardState) { return; } for (let ax = 0; ax < BOARD_SIZE; ax++) { for (let ay = 0; ay < BOARD_SIZE; ay++) { for (let az_coord = 0; az_coord < gameState.maxHeight; az_coord++) { const attackerPieceInfo = getPieceAt(ax, ay, az_coord); if (attackerPieceInfo) { const pseudoMoves = _calculatePseudoLegalMoves(attackerPieceInfo, ax, ay, az_coord, boardState); for (const move of pseudoMoves) { if (move.isCapture) { const targetPieceInfo = getPieceAt(move.x, move.y, move.z); if (targetPieceInfo && targetPieceInfo.color !== attackerPieceInfo.color) { const key = `${ax},${ay},${az_coord}->${move.x},${move.y},${move.z}`; if (!conflictRayHash.has(key)) { conflictRayHash.add(key); addConflictRay(ax, ay, az_coord, move.x, move.y, move.z, attackerPieceInfo.color); } } } } } } } } }
        function animate() { requestAnimationFrame(animate); if(controls) controls.update(); renderer.render(scene, camera); }
        document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('.height-button').forEach(button => { button.addEventListener('click', () => { document.querySelectorAll('.height-button').forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); gameState.selectedSetupType = button.dataset.setup; }); }); document.querySelectorAll('.axis-button').forEach(button => { button.addEventListener('click', () => { document.querySelectorAll('.axis-button').forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); gameState.upAxis = button.dataset.axis; }); }); document.getElementById('start-game-button').addEventListener('click', startGame); if (!document.querySelector('.height-button.selected')) { document.querySelector('.height-button[data-setup="low"]').classList.add('selected'); gameState.selectedSetupType = 'low'; } if (!document.querySelector('.axis-button.selected')) { document.querySelector('.axis-button[data-axis="y"]').classList.add('selected'); gameState.upAxis = 'y'; } });
    </script>
</body>
</html>